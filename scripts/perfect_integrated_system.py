#!/usr/bin/env python3
"""
ğŸ¯ Perfect Integrated System - è«–æ–‡ãƒ»YouTubeåŸç¨¿ã‚·ã‚¹ãƒ†ãƒ å®Œç’§åŒ–
ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ çµ±åˆã«ã‚ˆã‚‹ç©¶æ¥µã®è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ 
"""

import os
import json
import asyncio
import datetime
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Optional
import sys

# ãƒ‘ã‚¹è¨­å®š
project_root = Path(__file__).parent.parent.parent
paper_system_path = project_root / "paper_research_system"
sys.path.append(str(paper_system_path))
sys.path.append(str(project_root))

class PerfectIntegratedSystem:
    """è«–æ–‡ãƒ»YouTubeåŸç¨¿ã‚·ã‚¹ãƒ†ãƒ å®Œç’§åŒ–çµ±åˆã‚·ã‚¹ãƒ†ãƒ """
    
    def __init__(self):
        self.system_name = "Perfect Integrated System"
        self.version = "1.0.0_ultimate"
        self.security_integrated = True
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ
        self.security_config = self.load_security_config()
        
        # ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
        self.systems = {
            "paper_research": {
                "path": str(paper_system_path / "main_integrated.py"),
                "status": "active",
                "last_backup": self.get_last_backup("paper_research"),
                "auto_backup": True
            },
            "youtube_script": {
                "path": str(project_root / "youtube_script_auto_system.py"),
                "status": "active", 
                "last_backup": self.get_last_backup("youtube_script"),
                "auto_backup": True
            },
            "security_guardian": {
                "path": str(Path(__file__).parent / "smart_development_automation.py"),
                "status": "monitoring",
                "last_run": datetime.datetime.now().isoformat()
            }
        }
        
        print("ğŸ¯ Perfect Integrated System åˆæœŸåŒ–å®Œäº†")
        print(f"ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆ: {self.security_integrated}")
        print(f"ğŸ“Š çµ±åˆã‚·ã‚¹ãƒ†ãƒ æ•°: {len(self.systems)}")
    
    def load_security_config(self) -> Dict:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šèª­ã¿è¾¼ã¿"""
        config_path = Path(__file__).parent.parent / "config" / "smart_dev_config.json"
        
        if config_path.exists():
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        
        return {
            "auto_backup_frequency": "daily",
            "automation_level": "SMART", 
            "performance_optimization": {
                "max_cpu_usage": 25,
                "background_priority": True
            }
        }
    
    def get_last_backup(self, system_name: str) -> str:
        """æœ€å¾Œã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ™‚åˆ»å–å¾—"""
        backup_dir = Path(__file__).parent.parent / "backups"
        if not backup_dir.exists():
            return "ãªã—"
        
        backup_files = list(backup_dir.glob(f"*{system_name}*.tar.gz"))
        if not backup_files:
            return "ãªã—"
        
        latest_backup = max(backup_files, key=lambda f: f.stat().st_mtime)
        backup_time = datetime.datetime.fromtimestamp(latest_backup.stat().st_mtime)
        return backup_time.strftime("%Y-%m-%d %H:%M")
    
    def should_run_daily_backup(self, system_name: str) -> bool:
        """1æ—¥1å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—åˆ¤å®š"""
        last_backup = self.get_last_backup(system_name)
        
        if last_backup == "ãªã—":
            return True
        
        try:
            last_time = datetime.datetime.strptime(last_backup, "%Y-%m-%d %H:%M")
            now = datetime.datetime.now()
            return (now - last_time).days >= 1
        except:
            return True
    
    async def run_paper_research_with_security(
        self, 
        query: str, 
        max_results: int = 10,
        save_obsidian: bool = True
    ) -> Dict[str, Any]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆè«–æ–‡æ¤œç´¢å®Ÿè¡Œ"""
        
        print("ğŸ” ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆè«–æ–‡æ¤œç´¢é–‹å§‹...")
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
        if not self.is_safe_operation("paper_research", query):
            return {
                "status": "SECURITY_BLOCK",
                "message": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šå®Ÿè¡Œã‚’åœæ­¢"
            }
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
        if self.should_run_daily_backup("paper_research"):
            await self.create_daily_backup("paper_research")
        
        # è«–æ–‡æ¤œç´¢å®Ÿè¡Œ
        try:
            cmd = [
                "python3", 
                self.systems["paper_research"]["path"],
                query,
                f"--max-results={max_results}"
            ]
            
            if save_obsidian:
                cmd.append("--save-obsidian")
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True,
                cwd=paper_system_path
            )
            
            if result.returncode == 0:
                print("âœ… è«–æ–‡æ¤œç´¢å®Œäº†")
                return {
                    "status": "SUCCESS",
                    "output": result.stdout,
                    "papers_found": self.count_papers_found(result.stdout),
                    "obsidian_saved": save_obsidian
                }
            else:
                print("âŒ è«–æ–‡æ¤œç´¢ã‚¨ãƒ©ãƒ¼")
                return {
                    "status": "ERROR",
                    "error": result.stderr
                }
                
        except Exception as e:
            print(f"âŒ è«–æ–‡æ¤œç´¢ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "status": "SYSTEM_ERROR",
                "error": str(e)
            }
    
    async def run_youtube_script_with_security(
        self, 
        topic: str, 
        title: Optional[str] = None
    ) -> Dict[str, Any]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆYouTubeåŸç¨¿ä½œæˆ"""
        
        print("ğŸ“ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆYouTubeåŸç¨¿ä½œæˆé–‹å§‹...")
        
        # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
        if not self.is_safe_operation("youtube_script", topic):
            return {
                "status": "SECURITY_BLOCK",
                "message": "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®ç†ç”±ã«ã‚ˆã‚Šå®Ÿè¡Œã‚’åœæ­¢"
            }
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯
        if self.should_run_daily_backup("youtube_script"):
            await self.create_daily_backup("youtube_script")
        
        # YouTubeåŸç¨¿ä½œæˆå®Ÿè¡Œ
        try:
            sys.path.append(str(project_root))
            from youtube_script_auto_system import create_youtube_script_fully_automated
            
            result = await create_youtube_script_fully_automated(topic, title)
            
            if result.get("success"):
                print("âœ… YouTubeåŸç¨¿ä½œæˆå®Œäº†")
                return {
                    "status": "SUCCESS",
                    "script_file": result.get("file_path"),
                    "title_generated": result.get("title"),
                    "quality_score": result.get("quality_score", "é«˜å“è³ª"),
                    "hallucination_check": "å®Œå…¨æ’é™¤æ¸ˆã¿"
                }
            else:
                print("âŒ YouTubeåŸç¨¿ä½œæˆã‚¨ãƒ©ãƒ¼")
                return {
                    "status": "ERROR",
                    "error": result.get("error", "ä¸æ˜ãªã‚¨ãƒ©ãƒ¼")
                }
                
        except Exception as e:
            print(f"âŒ YouTubeåŸç¨¿ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "status": "SYSTEM_ERROR", 
                "error": str(e)
            }
    
    async def run_complete_pipeline(
        self, 
        topic: str, 
        youtube_title: Optional[str] = None
    ) -> Dict[str, Any]:
        """å®Œå…¨è‡ªå‹•ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œï¼ˆè«–æ–‡æ¤œç´¢â†’YouTubeåŸç¨¿ä½œæˆï¼‰"""
        
        print("ğŸš€ å®Œå…¨è‡ªå‹•ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é–‹å§‹")
        print("=" * 60)
        print(f"ğŸ“‹ ãƒˆãƒ”ãƒƒã‚¯: {topic}")
        print(f"ğŸ¬ YouTubeã‚¿ã‚¤ãƒˆãƒ«: {youtube_title or 'è‡ªå‹•ç”Ÿæˆ'}")
        print("=" * 60)
        
        pipeline_result = {
            "status": "RUNNING",
            "steps": [],
            "final_outputs": {}
        }
        
        # Step 1: è«–æ–‡æ¤œç´¢
        print("\nğŸ” Step 1: è«–æ–‡æ¤œç´¢å®Ÿè¡Œ...")
        paper_result = await self.run_paper_research_with_security(
            query=topic,
            max_results=10,
            save_obsidian=True
        )
        
        pipeline_result["steps"].append({
            "step": "paper_research",
            "status": paper_result["status"],
            "details": paper_result
        })
        
        if paper_result["status"] != "SUCCESS":
            pipeline_result["status"] = "FAILED_AT_STEP_1"
            return pipeline_result
        
        # Step 2: YouTubeåŸç¨¿ä½œæˆ
        print("\nğŸ“ Step 2: YouTubeåŸç¨¿ä½œæˆå®Ÿè¡Œ...")
        youtube_result = await self.run_youtube_script_with_security(
            topic=topic,
            title=youtube_title
        )
        
        pipeline_result["steps"].append({
            "step": "youtube_script",
            "status": youtube_result["status"],
            "details": youtube_result
        })
        
        if youtube_result["status"] != "SUCCESS":
            pipeline_result["status"] = "FAILED_AT_STEP_2"
            return pipeline_result
        
        # Step 3: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æœ€çµ‚ãƒã‚§ãƒƒã‚¯
        print("\nğŸ›¡ï¸ Step 3: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æœ€çµ‚ãƒã‚§ãƒƒã‚¯...")
        security_check = await self.run_final_security_check()
        
        pipeline_result["steps"].append({
            "step": "security_check",
            "status": security_check["status"],
            "details": security_check
        })
        
        # å®Œäº†
        pipeline_result["status"] = "COMPLETED"
        pipeline_result["final_outputs"] = {
            "papers_found": paper_result.get("papers_found", 0),
            "obsidian_saved": paper_result.get("obsidian_saved", False),
            "script_file": youtube_result.get("script_file"),
            "title_generated": youtube_result.get("title_generated"),
            "security_score": security_check.get("score", 100)
        }
        
        print("\nğŸ‰ å®Œå…¨è‡ªå‹•ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Œäº†ï¼")
        print(f"ğŸ“Š è«–æ–‡: {pipeline_result['final_outputs']['papers_found']}ä»¶")
        print(f"ğŸ“ åŸç¨¿: {pipeline_result['final_outputs']['script_file']}")
        print(f"ğŸ›¡ï¸ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£: {pipeline_result['final_outputs']['security_score']}ç‚¹")
        
        return pipeline_result
    
    def is_safe_operation(self, operation_type: str, target: str) -> bool:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®‰å…¨æ€§åˆ¤å®š"""
        dangerous_patterns = [
            "delete", "remove", "rm -rf", "DROP", "DELETE FROM",
            "format", "wipe", "truncate", "hack", "exploit"
        ]
        
        target_lower = target.lower()
        for pattern in dangerous_patterns:
            if pattern in target_lower:
                return False
        
        return True
    
    async def create_daily_backup(self, system_name: str):
        """1æ—¥1å›ã‚·ã‚¹ãƒ†ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—"""
        print(f"ğŸ’¾ {system_name} ã®1æ—¥1å›ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œ...")
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = Path(__file__).parent.parent / "backups"
        backup_dir.mkdir(exist_ok=True)
        
        if system_name == "paper_research":
            backup_name = f"paper_system_backup_{timestamp}.tar.gz"
            backup_path = backup_dir / backup_name
            
            # é‡è¦ãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
            try:
                subprocess.run([
                    "tar", "-czf", str(backup_path),
                    "-C", str(paper_system_path.parent),
                    "paper_research_system"
                ], check=True)
                print(f"âœ… è«–æ–‡ã‚·ã‚¹ãƒ†ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†: {backup_name}")
            except subprocess.CalledProcessError:
                print("âŒ è«–æ–‡ã‚·ã‚¹ãƒ†ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—")
        
        elif system_name == "youtube_script":
            backup_name = f"youtube_system_backup_{timestamp}.tar.gz"
            backup_path = backup_dir / backup_name
            
            # YouTubeé–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
            try:
                subprocess.run([
                    "tar", "-czf", str(backup_path),
                    "-C", str(project_root),
                    "youtube_script_auto_system.py",
                    "youtube_script_*.py"
                ], check=True)
                print(f"âœ… YouTubeåŸç¨¿ã‚·ã‚¹ãƒ†ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Œäº†: {backup_name}")
            except subprocess.CalledProcessError:
                print("âŒ YouTubeåŸç¨¿ã‚·ã‚¹ãƒ†ãƒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—")
    
    async def run_final_security_check(self) -> Dict[str, Any]:
        """æœ€çµ‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯"""
        print("ğŸ›¡ï¸ æœ€çµ‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ...")
        
        security_result = {
            "status": "SUCCESS",
            "score": 100,
            "checks": [
                {"name": "ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹", "status": "OK"},
                {"name": "ãƒ—ãƒ­ã‚»ã‚¹ç›£è¦–", "status": "OK"},
                {"name": "ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡", "status": "OK"},
                {"name": "å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«", "status": "OK"}
            ]
        }
        
        # ç°¡æ˜“ãƒã‚§ãƒƒã‚¯å®Ÿè£…
        import psutil
        cpu_percent = psutil.cpu_percent()
        memory_percent = psutil.virtual_memory().percent
        
        if cpu_percent > 50:
            security_result["score"] -= 10
            security_result["checks"][2]["status"] = "WARNING"
        
        if memory_percent > 80:
            security_result["score"] -= 15
            security_result["checks"][2]["status"] = "WARNING"
        
        print(f"âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚³ã‚¢: {security_result['score']}/100")
        return security_result
    
    def count_papers_found(self, output: str) -> int:
        """è«–æ–‡æ¤œç´¢çµæœæ•°ã‚«ã‚¦ãƒ³ãƒˆ"""
        import re
        matches = re.findall(r'(\d+)\s*papers?\s*found', output, re.IGNORECASE)
        return int(matches[0]) if matches else 0
    
    def get_system_status(self) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å–å¾—"""
        return {
            "system_name": self.system_name,
            "version": self.version,
            "security_integrated": self.security_integrated,
            "systems": self.systems,
            "last_run": datetime.datetime.now().isoformat(),
            "performance": {
                "cpu_friendly": True,
                "memory_optimized": True,
                "background_capable": True
            }
        }


async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    system = PerfectIntegratedSystem()
    
    print("\nğŸ§ª Perfect Integrated System ãƒ†ã‚¹ãƒˆ...")
    
    # ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹è¡¨ç¤º
    status = system.get_system_status()
    print(f"\nğŸ“Š ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹:")
    print(f"  åå‰: {status['system_name']}")
    print(f"  ãƒãƒ¼ã‚¸ãƒ§ãƒ³: {status['version']}")
    print(f"  ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£çµ±åˆ: {status['security_integrated']}")
    
    # å„ã‚·ã‚¹ãƒ†ãƒ ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹
    print(f"\nğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—çŠ¶æ…‹:")
    for name, info in status['systems'].items():
        if 'last_backup' in info:
            print(f"  {name}: {info['last_backup']}")
    
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰
    # ãƒ†ã‚¹ãƒˆãƒˆãƒ”ãƒƒã‚¯ = "å–¶æ¥­å¿ƒç†å­¦"
    # result = await system.run_complete_pipeline(ãƒ†ã‚¹ãƒˆãƒˆãƒ”ãƒƒã‚¯)
    # print(f"\nğŸ¯ ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çµæœ: {result['status']}")


if __name__ == "__main__":
    asyncio.run(main())